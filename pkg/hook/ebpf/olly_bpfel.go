// Code generated by bpf2go; DO NOT EDIT.
// This is a placeholder. Run `go generate ./pkg/hook/ebpf/` on Linux with
// clang installed to regenerate from olly.bpf.c.

//go:build linux

package ebpf

import (
	"fmt"

	"github.com/cilium/ebpf"
)

// ollyObjects contains all objects after they have been loaded into the kernel.
type ollyObjects struct {
	ollyPrograms
	ollyMaps
}

func (o *ollyObjects) Close() error {
	o.ollyPrograms.Close()
	o.ollyMaps.Close()
	return nil
}

// ollyMaps contains all maps.
type ollyMaps struct {
	ConnMap        *ebpf.Map `ebpf:"conn_map"`
	PidFilter      *ebpf.Map `ebpf:"pid_filter"`
	LogFdMap       *ebpf.Map `ebpf:"log_fd_map"`
	SslFdMap       *ebpf.Map `ebpf:"ssl_fd_map"`
	TracingEnabled *ebpf.Map `ebpf:"tracing_enabled"`
	Events         *ebpf.Map `ebpf:"events"`
}

func (m *ollyMaps) Close() error {
	maps := []*ebpf.Map{
		m.ConnMap, m.PidFilter, m.LogFdMap,
		m.SslFdMap, m.TracingEnabled, m.Events,
	}
	for _, mp := range maps {
		if mp != nil {
			mp.Close()
		}
	}
	return nil
}

// ollyPrograms contains all programs.
type ollyPrograms struct {
	KprobeConnect    *ebpf.Program `ebpf:"kprobe_connect"`
	KretprobeConnect *ebpf.Program `ebpf:"kretprobe_connect"`
	KprobeAccept4    *ebpf.Program `ebpf:"kprobe_accept4"`
	KretprobeAccept4 *ebpf.Program `ebpf:"kretprobe_accept4"`
	KprobeAccept     *ebpf.Program `ebpf:"kprobe_accept"`
	KretprobeAccept  *ebpf.Program `ebpf:"kretprobe_accept"`
	KprobeWrite      *ebpf.Program `ebpf:"kprobe_write"`
	KprobeSendto     *ebpf.Program `ebpf:"kprobe_sendto"`
	KprobeRead       *ebpf.Program `ebpf:"kprobe_read"`
	KretprobeRead    *ebpf.Program `ebpf:"kretprobe_read"`
	KprobeRecvfrom   *ebpf.Program `ebpf:"kprobe_recvfrom"`
	KretprobeRecvfrom *ebpf.Program `ebpf:"kretprobe_recvfrom"`
	KprobeClose      *ebpf.Program `ebpf:"kprobe_close"`

	// SSL uprobes
	UprobeSslSetFd    *ebpf.Program `ebpf:"uprobe_ssl_set_fd"`
	UprobeSslWrite    *ebpf.Program `ebpf:"uprobe_ssl_write"`
	UretprobeSslWrite *ebpf.Program `ebpf:"uretprobe_ssl_write"`
	UprobeSslRead     *ebpf.Program `ebpf:"uprobe_ssl_read"`
	UretprobeSslRead  *ebpf.Program `ebpf:"uretprobe_ssl_read"`

	// Tracepoints
	TracepointSchedSchedProcessExec *ebpf.Program `ebpf:"tracepoint_sched_sched_process_exec"`
}

func (p *ollyPrograms) Close() error {
	progs := []*ebpf.Program{
		p.KprobeConnect, p.KretprobeConnect,
		p.KprobeAccept4, p.KretprobeAccept4,
		p.KprobeAccept, p.KretprobeAccept,
		p.KprobeWrite, p.KprobeSendto,
		p.KprobeRead, p.KretprobeRead,
		p.KprobeRecvfrom, p.KretprobeRecvfrom,
		p.KprobeClose,
		p.UprobeSslSetFd, p.UprobeSslWrite, p.UretprobeSslWrite,
		p.UprobeSslRead, p.UretprobeSslRead,
		p.TracepointSchedSchedProcessExec,
	}
	for _, prog := range progs {
		if prog != nil {
			prog.Close()
		}
	}
	return nil
}

// loadOllyObjects loads all BPF objects into the kernel.
// This placeholder returns an error â€” run `go generate` to embed real bytecode.
func loadOllyObjects(obj *ollyObjects, opts *ebpf.CollectionOptions) error {
	return fmt.Errorf("eBPF bytecode not generated: run 'go generate ./pkg/hook/ebpf/' on Linux with clang")
}
